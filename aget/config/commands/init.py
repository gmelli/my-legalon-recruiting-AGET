"""
Init Command - Creates AGENTS.md configuration
Implements three-tier degradation pattern.
"""

import os
import subprocess
from pathlib import Path
from typing import Any, Dict, List

from aget.base import BaseCommand


class InitCommand(BaseCommand):
    """Initialize agent configuration with appropriate tier."""

    def __init__(self):
        """Initialize with template options."""
        super().__init__()

        # Template configurations
        # Note: Using 'workspace' for private and 'products' for public
        # to avoid case sensitivity issues on macOS/Windows
        self.templates = {
            'minimal': {
                'dirs': ['.aget', '.aget/evolution'],
                'description': 'Basic agent configuration'
            },
            'standard': {
                'dirs': ['.aget', '.aget/evolution', 'workspace', 'data'],
                'description': 'Standard workspace with outputs and data'
            },
            'agent': {
                'dirs': [
                    '.aget', '.aget/evolution', '.aget/checkpoints',
                    'src', 'workspace', 'products', 'data',
                    'docs', 'tests'
                ],
                'description': 'Full autonomous agent structure'
            },
            'tool': {
                'dirs': [
                    '.aget', '.aget/evolution',
                    'src', 'products', 'docs', 'tests'
                ],
                'description': 'Tool/library development structure'
            },
            'hybrid': {
                'dirs': [
                    '.aget', '.aget/evolution', '.aget/checkpoints',
                    'src', 'workspace', 'products', 'data',
                    'docs', 'tests', 'examples'
                ],
                'description': 'Combined agent and tool structure'
            }
        }

        self.default_template = """# Agent Configuration

## Project Context
{project_name} - Created with AGET v2 ({template_type} template)

## Session Management Protocols

### Wake Up Protocol
When user says "wake up" or "hey":
- Show current directory and status
- Check git status
- Report readiness

### Wind Down Protocol
When user says "wind down" or "save work":
- Commit changes
- Create session notes
- Show completion

### Sign Off Protocol
When user says "sign off" or "all done":
- Quick save and exit
- No questions

## Directory Structure
{directory_structure}

## Vocabulary Note
- `workspace/` = Your agent's private workspace for exploration
- `products/` = Public products your agent creates/maintains for others
- `src/` = Source code for your agent/tool
- `.aget/evolution/` = Decision and discovery tracking

## Available Patterns
Run `aget list` to see available patterns you can apply.

---
*Generated by AGET v2 - https://github.com/gmelli/aget-cli-agent-template*
"""

    def tier_basic(self, **kwargs) -> Dict[str, Any]:
        """
        Basic tier - Create AGENTS.md and directories based on template.
        No external tools required.
        """
        args = kwargs.get('args', [])

        # Determine project path
        project_path = Path.cwd()
        if args and len(args) > 0:
            if args[0] != '.' and not args[0].startswith('--'):
                project_path = Path(args[0])

        # Parse template option
        template_type = 'standard'  # default
        with_patterns = False
        separate_mode = False  # New v2.0 include architecture
        for i, arg in enumerate(args):
            if arg == '--template' and i + 1 < len(args):
                template_type = args[i + 1]
            elif arg == '--with-patterns':
                with_patterns = True
            elif arg == '--separate':
                separate_mode = True  # Use include architecture

        # Validate template
        if template_type not in self.templates:
            return {
                'success': False,
                'error': f'Invalid template: {template_type}. Options: {", ".join(self.templates.keys())}'
            }

        # Create AGENTS.md
        agents_file = project_path / "AGENTS.md"
        if agents_file.exists() and '--force' not in args:
            return {
                'success': False,
                'error': 'AGENTS.md already exists. Use --force to overwrite.'
            }

        # Create directories based on template
        template_config = self.templates[template_type]
        created_dirs = []
        for dir_path in template_config['dirs']:
            full_path = project_path / dir_path
            full_path.mkdir(parents=True, exist_ok=True)
            created_dirs.append(dir_path)

            # Add README.md to key directories
            readme_content = self._get_readme_content(dir_path)
            if readme_content:
                readme_file = full_path / "README.md"
                if not readme_file.exists():
                    readme_file.write_text(readme_content)

        # Generate directory structure documentation
        directory_docs = self._generate_directory_docs(template_type)

        # Create content based on mode
        if separate_mode:
            # v2.0 Include Architecture - Create both files
            agents_aget_file = project_path / "AGENTS_AGET.md"

            # 1. Create AGENTS_AGET.md with framework protocols
            aget_template_path = Path(__file__).parent.parent.parent.parent / 'templates' / 'AGENTS_AGET.md'
            if aget_template_path.exists():
                agents_aget_file.write_text(aget_template_path.read_text())
            else:
                # Fallback if template not found
                agents_aget_file.write_text(self._get_default_aget_content())

            # 2. Create AGENTS.md with procedural instructions
            agents_template_path = Path(__file__).parent.parent.parent.parent / 'templates' / 'AGENTS_v2.md'
            if agents_template_path.exists():
                content = agents_template_path.read_text()
                # Replace placeholders
                content = content.replace('[Project Name]', project_path.name)
                content = content.replace('[Your project description here]',
                                        f'{project_path.name} - Created with AGET v2 ({template_type} template)')
                content = content.replace('[Your coding standards, conventions, etc.]',
                                        f'Directory structure:\n{directory_docs}')
            else:
                # Fallback to inline template
                content = self._get_separate_mode_template(project_path.name, template_type, directory_docs)

            agents_file.write_text(content)
            print("✅ Created AGENTS_AGET.md (framework protocols)")
            print("✅ Created AGENTS.md (project config with include instructions)")

        else:
            # Traditional single-file mode
            content = self.default_template.format(
                project_name=project_path.name,
                template_type=template_type,
                directory_structure=directory_docs
            )
            agents_file.write_text(content)

        # Create version tracking
        aget_dir = project_path / ".aget"
        version_file = aget_dir / "version.json"
        version_data = {
            "aget_version": "2.1.0",
            "created": "2025-09-24",
            "template": template_type,
            "tier": "basic"
        }
        import json
        version_file.write_text(json.dumps(version_data, indent=2))

        # Create CLAUDE.md symlink for backward compatibility
        claude_file = project_path / "CLAUDE.md"

        # Handle existing CLAUDE.md with content preservation
        if claude_file.exists():
            if '--force' in args and '--no-preserve' in args:
                # Only with explicit no-preserve flag do we destroy content
                claude_file.unlink()
            elif claude_file.exists() and not claude_file.is_symlink():
                # Preserve existing custom content and merge with AGET
                from aget.config.commands.merge_content import ContentMerger
                merger = ContentMerger()

                # Backup original
                backup_file = project_path / "CLAUDE.md.backup"
                backup_file.write_text(claude_file.read_text())

                # Merge contents
                merged_content = merger.merge_contents(
                    existing_content=claude_file.read_text(),
                    aget_content=agents_file.read_text()
                )

                # Write merged content
                claude_file.write_text(merged_content)

                # Also update AGENTS.md to match
                agents_file.write_text(merged_content)
            else:
                # Already a symlink, update AGENTS.md will update both
                pass

        # Create symlink or copy content (only if doesn't exist)
        if not claude_file.exists():
            try:
                claude_file.symlink_to("AGENTS.md")
            except (OSError, FileExistsError):
                # Windows or permission issues - copy content instead
                claude_file.write_text(agents_file.read_text())

        # Create other agent tool configs for universal compatibility
        # Cursor
        cursor_file = project_path / ".cursorrules"
        if not cursor_file.exists() or '--force' in args:
            cursor_file.write_text(agents_file.read_text())

        # Aider (basic config pointing to AGENTS.md)
        aider_file = project_path / ".aider.conf.yml"
        if not aider_file.exists() or '--force' in args:
            aider_config = """# Aider configuration
# See AGENTS.md for detailed instructions
read-only-files:
  - AGENTS.md
"""
            aider_file.write_text(aider_config)

        # Apply patterns if requested
        patterns_applied = []
        if with_patterns:
            # Import apply command
            from aget.config.commands.apply import ApplyCommand
            apply_cmd = ApplyCommand()

            # Determine which patterns to apply based on template
            patterns_to_apply = self._get_patterns_for_template(template_type)

            for pattern in patterns_to_apply:
                # Call tier_basic directly with kwargs
                result = apply_cmd.tier_basic(args=[pattern])
                if result.get('success'):
                    patterns_applied.append(pattern)

        message = f'Created {template_type} template in {project_path}'
        if separate_mode:
            message += ' (v2.0 include architecture)'
        if patterns_applied:
            message += f' with {len(patterns_applied)} patterns applied'

        files_created = ['AGENTS.md', 'CLAUDE.md']
        if separate_mode:
            files_created.append('AGENTS_AGET.md')

        return {
            'success': True,
            'message': message,
            'template': template_type,
            'description': template_config['description'],
            'files_created': files_created + created_dirs,
            'patterns_applied': patterns_applied if with_patterns else [],
            'separate_mode': separate_mode
        }

    def _get_patterns_for_template(self, template_type: str) -> List[str]:
        """Get list of patterns to apply for each template type."""
        pattern_map = {
            'minimal': ['session/wake'],
            'standard': ['session/wake', 'session/wind_down', 'housekeeping/cleanup'],
            'agent': [
                'session/wake', 'session/wind_down', 'session/sign_off',
                'housekeeping/cleanup', 'housekeeping/sanity_check'
            ],
            'tool': ['session/wake', 'housekeeping/cleanup'],
            'hybrid': [
                'session/wake', 'session/wind_down', 'session/sign_off',
                'housekeeping/cleanup', 'housekeeping/sanity_check'
            ]
        }
        return pattern_map.get(template_type, [])

    def _get_separate_mode_template(self, project_name: str, template_type: str, dir_tree: str) -> str:
        """Get AGENTS.md content for separate mode."""
        return f"""# Agent Configuration - {project_name}

## 🚨 CRITICAL: INITIALIZATION PROCEDURE (REQUIRED)

**You MUST follow these steps IMMEDIATELY:**

**Step 1:** Check if file `AGENTS_AGET.md` exists in this directory
**Step 2:** If it exists, **READ IT IMMEDIATELY** for all AGET protocols
**Step 3:** Use the protocols from AGENTS_AGET.md for all standard commands
**Step 4:** Return here for project-specific configuration

> ⚠️ **IMPORTANT**: If you skip reading AGENTS_AGET.md, you will not have access to session management, housekeeping, or other AGET commands.

---

## Project Context

{project_name} - Created with AGET v2 ({template_type} template)

## Directory Structure
{dir_tree}

## Project-Specific Commands

[Add your custom commands and workflows here]

## Development Workflow

[Your specific development process]

---

## ✅ VERIFICATION CHECKLIST

Before proceeding, confirm you have:
- [ ] Read AGENTS_AGET.md for AGET protocols
- [ ] Understood the session management commands
- [ ] Understood the housekeeping commands
- [ ] Noted the project-specific configuration above

**Remember**: AGENTS_AGET.md = Framework protocols, This file = Your project config

---
*Project configured with AGET v2.0 - Include Architecture*
"""

    def _get_default_aget_content(self) -> str:
        """Fallback AGENTS_AGET.md content if template not found."""
        return """# AGET Standard Protocols v2.1.0

**Framework File** - Maintained by AGET, not project-specific
**Version**: 2.1.0

## Session Management Protocols

### Wake Up
When user says "wake up" or "hey": Run wake protocol

### Wind Down
When user says "wind down" or "save work": Save and create notes

### Sign Off
When user says "sign off" or "all done": Quick save and push

## Housekeeping Protocols

### Tidy Up
When user says "tidy up" or "housekeeping": Clean temporary files

### Check Docs
When user says "check docs": Analyze documentation quality

### Health Check
When user says "health check" or "sanity check": Run diagnostics

---
*This file is part of AGET v2.0*
"""

    def _get_readme_content(self, dir_path: str) -> str:
        """Generate README content for specific directories."""
        readmes = {
            'workspace': """# Workspace Directory

This is your agent's private workspace for exploration and experimentation.

## Purpose
- Internal tools and scripts
- Work-in-progress code
- Experimental features
- Private explorations

## Note
Content here is NOT intended for public use. When ready to share,
use `aget extract` to move to products/ directory.
""",
            'products': """# Products Directory (Public)

This directory contains public products created and maintained by the agent.

## Purpose
- Standalone tools ready for public use
- Extracted and sanitized utilities
- Documentation and examples
- Published packages

## Publishing
Use `aget extract --from workspace/ --to products/` to promote internal
tools to public products.
""",
            'src': """# Source Code

Main source code for this project.

## Structure
Organize by functionality or component as appropriate for your project.
""",
            '.aget/evolution': """# Evolution Tracking

This directory captures the agent's decision-making process and discoveries.

## Entry Types
- **decisions/** - Architectural and design decisions
- **discoveries/** - Patterns and insights found
- **extractions/** - Records of outputs→Outputs promotions

## Usage
Use `aget evolution --type <type>` to add entries.
""",
            'data': """# Data Directory

Persistent data storage for the agent.

## Usage
- Configuration files
- Cached data
- Training data
- Results and metrics
""",
            'tests': """# Tests Directory

Test suite for this project.

## Running Tests
```bash
python -m pytest tests/
```
""",
            'docs': """# Documentation

Project documentation and guides.

## Contents
- Architecture documentation
- API references
- User guides
- Development notes
""",
            'examples': """# Examples

Example usage and demonstrations.

## Purpose
- Show how to use the tools/agent
- Provide templates for common tasks
- Demonstrate best practices
"""
        }

        # Return content if we have it, otherwise None
        return readmes.get(dir_path)

    def _generate_directory_docs(self, template_type: str) -> str:
        """Generate directory structure documentation for AGENTS.md."""
        docs = {
            'minimal': """- `.aget/` - Framework metadata and configuration
- `.aget/evolution/` - Decision and discovery tracking""",

            'standard': """- `.aget/` - Framework metadata and configuration
- `.aget/evolution/` - Decision and discovery tracking
- `workspace/` - Agent's internal workspace (private explorations)
- `data/` - Persistent data storage""",

            'agent': """- `.aget/` - Framework metadata and configuration
- `.aget/evolution/` - Decision and discovery tracking
- `.aget/checkpoints/` - Agent state checkpoints
- `src/` - Agent source code
- `workspace/` - Internal workspace for explorations
- `products/` - Public products the agent maintains
- `data/` - Persistent data storage
- `docs/` - Documentation
- `tests/` - Test suite""",

            'tool': """- `.aget/` - Framework metadata and configuration
- `.aget/evolution/` - Decision and discovery tracking
- `src/` - Tool source code
- `products/` - Public tool/library
- `docs/` - Documentation
- `tests/` - Test suite""",

            'hybrid': """- `.aget/` - Framework metadata and configuration
- `.aget/evolution/` - Decision and discovery tracking
- `.aget/checkpoints/` - Agent state checkpoints
- `src/` - Source code for agent and tools
- `workspace/` - Internal workspace for explorations
- `products/` - Public products maintained
- `data/` - Persistent data storage
- `docs/` - Documentation
- `tests/` - Test suite
- `examples/` - Usage examples"""
        }

        return docs.get(template_type, docs['standard'])

    def tier_git(self, **kwargs) -> Dict[str, Any]:
        """
        Git tier - Also update .gitignore.
        """
        # First do everything basic tier does
        result = self.tier_basic(**kwargs)
        if not result['success']:
            return result

        args = kwargs.get('args', [])
        project_path = Path.cwd()
        if args and len(args) > 0 and args[0] != '.' and not args[0].startswith('--'):
            project_path = Path(args[0])

        # Get template type to add appropriate ignores
        template_type = result.get('template', 'standard')

        # Update .gitignore
        gitignore = project_path / ".gitignore"
        ignore_lines = [
            "# AGET files",
            ".aget/backups/",
            ".aget/cache/",
            ".aget/checkpoints/",
            ".session_state.json",
            "",
            "# Python",
            "__pycache__/",
            "*.py[cod]",
            "*$py.class",
            ".pytest_cache/",
            "",
            "# Environment",
            ".env",
            "venv/",
            "env/",
        ]

        # Add template-specific ignores
        if template_type in ['agent', 'hybrid']:
            ignore_lines.extend([
                "",
                "# Agent workspace",
                "workspace/.tmp/",
                "workspace/*.log",
                "workspace/__pycache__/",
            ])

        if gitignore.exists():
            content = gitignore.read_text()
            for line in ignore_lines:
                if line and line not in content:
                    content += f"\n{line}"
            gitignore.write_text(content)
        else:
            gitignore.write_text("\n".join(ignore_lines) + "\n")

        result['files_created'].append('.gitignore')
        result['message'] += ' (git tier: updated .gitignore)'

        # Check if in git repo
        try:
            subprocess.run(
                ['git', 'rev-parse', '--git-dir'],
                cwd=project_path,
                capture_output=True,
                check=True,
                timeout=1
            )
            result['git_repo'] = True
        except:
            result['git_repo'] = False
            result['note'] = 'Not a git repository. Run `git init` to enable version control.'

        return result

    def tier_gh(self, **kwargs) -> Dict[str, Any]:
        """
        GitHub CLI tier - Also create issue templates.
        """
        # First do everything git tier does
        result = self.tier_git(**kwargs)
        if not result['success']:
            return result

        args = kwargs.get('args', [])
        project_path = Path.cwd()
        if args and len(args) > 0 and args[0] != '.' and not args[0].startswith('--'):
            project_path = Path(args[0])

        # Create .github/ISSUE_TEMPLATE for agent error reporting
        github_dir = project_path / ".github" / "ISSUE_TEMPLATE"
        github_dir.mkdir(parents=True, exist_ok=True)

        # Create agent error template
        agent_template = github_dir / "agent-error.yml"
        template_content = """name: Agent Error Report
description: Report an error encountered by an AI agent
title: "[Agent Error]: "
labels: ["agent-reported", "needs-triage"]
body:
  - type: dropdown
    id: agent_type
    attributes:
      label: Agent Type
      options:
        - Claude Code
        - Cursor
        - Aider
        - Windsurf
        - Other
    validations:
      required: true

  - type: textarea
    id: error_description
    attributes:
      label: Error Description
      description: What went wrong?
    validations:
      required: true

  - type: textarea
    id: context
    attributes:
      label: Context
      description: What was the agent trying to do?
    validations:
      required: true

  - type: textarea
    id: stack_trace
    attributes:
      label: Error Output
      description: Any error messages or stack traces
      render: shell
"""
        agent_template.write_text(template_content)

        result['files_created'].extend([
            '.github/ISSUE_TEMPLATE/',
            '.github/ISSUE_TEMPLATE/agent-error.yml'
        ])
        result['message'] += ' (gh tier: created issue templates)'

        # Check if gh is authenticated
        try:
            gh_check = subprocess.run(
                ['gh', 'auth', 'status'],
                capture_output=True,
                timeout=1
            )
            if gh_check.returncode == 0:
                result['gh_ready'] = True
            else:
                result['gh_ready'] = False
                result['gh_note'] = 'Run `gh auth login` to enable GitHub features'
        except:
            result['gh_ready'] = False

        return result